// Generated by Bisonc++ V6.04.01 on Fri, 18 Feb 2022 00:39:46 +0100

// hdr/includes
#ifndef u2dparserBase_h_included
#define u2dparserBase_h_included

#include <exception>
#include <vector>
#include <iostream>

// hdr/baseclass

namespace // anonymous
{
    struct PI_;
}

// $insert namespace-open
namespace u2d
{


// $insert parserbase
class parserBase
{
    public:
        enum DebugMode_
        {
            OFF           = 0,
            ON            = 1 << 0,
            ACTIONCASES   = 1 << 1
        };

// $insert tokens

    // Symbolic tokens:
    enum Tokens_
    {
        DOUBLE = 257,
        INTEGER,
        STRING,
        INIT,
        SERVER,
        LP,
        RP,
        _0,
        _1,
        _10,
        _20,
        _30,
        _40,
        _50,
        ACD,
        AM,
        BDR,
        BP,
        BAM,
        BD,
        BR,
        BS,
        BSM,
        BSA,
        BW,
        CBC,
        CP,
        CAL,
        CAW,
        CM,
        CADW,
        CDEFW,
        CDELW,
        CIW,
        CMD,
        CMPC,
        CMW,
        CRW,
        CWS,
        CO,
        COP,
        CWR,
        CW,
        CR,
        DAS,
        DPR,
        DBT,
        ED,
        EDT,
        EIN,
        EIT,
        EI,
        EM,
        EHT,
        ES,
        FKO,
        FC,
        FDP,
        FE,
        FKF,
        FSP,
        FWP,
        FL,
        FR,
        GLC,
        GLD,
        GLDIR,
        GLF,
        GLFN,
        GLV,
        GL,
        GOW,
        GW,
        GMM,
        GG,
        HT,
        HD,
        HI,
        HM,
        IM,
        K,
        KL,
        KLD,
        KLDIR,
        LKF,
        KLFN,
        KLG,
        KS,
        KW,
        KOW,
        KPR,
        KR,
        KRFL,
        KRFR,
        KM,
        LF,
        LDF,
        LT,
        MBTP,
        MAXDA,
        MDP,
        MGK,
        MTP,
        MAXM,
        MAXNA,
        MAXNM,
        MAXP,
        MINDA,
        MINDP,
        MINM,
        MINNA,
        MINNM,
        MINP,
        NEH,
        NNH,
        OAAS,
        OKM,
        OP,
        OCH,
        PAMK,
        PBSW,
        PCMP,
        PDX,
        PMET,
        PMGDX,
        PNK,
        PRW,
        PRWA,
        PSW,
        PTW,
        PSO,
        PAM,
        PD,
        PR,
        PS,
        PSM,
        PSMM,
        PW,
        PTB,
        PTD,
        P,
        PFL,
        PFR,
        PROF,
        PGK,
        QS,
        QSL,
        RM,
        RD,
        RDT,
        RI,
        RMIN,
        RS,
        RCP,
        SCCM,
        SCMS,
        SMS,
        SM,
        SS,
        SVS,
        SBS,
        SDR,
        SIMS,
        SDF,
        SOTFLT,
        SOTFRT,
        SC,
        SIM,
        SMAX,
        SGL,
        SGR,
        SBV,
        SMICS,
        SMOD,
        SO,
        SSO,
        TBD,
        TC,
        TD,
        TE,
        TPR,
        TRF,
        TW,
        TAN,
        TLS,
        TRS,
        TLC,
        TLD,
        TLDIR,
        TLF,
        TLFN,
        TL,
        UO,
        V,
        VA,
        VD,
        WA,
        WD,
        WF,
        WN,
        WR,
        WRA,
        PP,
        AMDT,
        CALSMAX,
        CALSMIN,
        DPRDMAX,
        DPRDMIN,
        EMAXDF,
        EMINDF,
        ESDMAX,
        ESDMIN,
        FDPDF,
        IMDF,
        KPRDMAX,
        KPRDMIN,
        KPRDF,
        KMDMAX,
        KMDMIN,
        NDPRDMAX,
        NDPRDMIN,
        NSIMAXDF,
        PDDMAX,
        PDDMIN,
        PSDF,
        PSMAXDMAX,
        PSMAXDMIN,
        PT,
        PTM,
        RANS,
        SIMAXDF,
        SUBMAX,
        PTY,
        ID,
        EMAX,
        CALS,
        PM_BKO,
        PM_PO,
        PM_TO,
        PM_KOL,
        PM_KOR,
        PM_KIL,
        PM_KIR,
        PM_FKL,
        PM_FKR,
        PM_CKL,
        PM_CKR,
        PM_GKL,
        PM_GKR,
        PM_GOALL,
        PM_GOALR,
        PM_DB,
        PM_OL,
        PM_OR,
        SEN,
        VM,
        VQ_L,
        VQ_H,
        VW_NA,
        VW_NO,
        VW_WI,
        ST,
        SP,
        HA,
        KICK,
        DASH,
        TURN,
        SAY,
        TNECK,
        CATCH,
        MOVE,
        CHVIEW,
        ARM,
        MOVABLE,
        EXP,
        TAR,
        COUNT,
        FOCUS,
        NONE,
        TACKLE,
        COLL,
        BALL,
        PLAYER,
        POST,
        FOUL,
        CHARGED,
        CARD,
        YELLOW,
        SEE,
        _C,
        _B,
        _F,
        _P,
        _G,
        _L,
        _R,
        _T,
        _BB,
        _FF,
        _GG,
        _PP,
        GOALIE,
        HEAR,
        OCL,
        OCR,
        REFEREE,
        SELF,
    };

// $insert STYPE
union STYPE_
{
double d;
int i;
bool b;
std::string* s;


};


    private:
                        // state  semval
        typedef std::pair<size_t, STYPE_> StatePair;
                       // token   semval
        typedef std::pair<int,    STYPE_> TokenPair;

        int d_stackIdx = -1;
        std::vector<StatePair> d_stateStack;
        StatePair  *d_vsp = 0;       // points to the topmost value stack
        size_t      d_state = 0;

        TokenPair   d_next;
        int         d_token;

        bool        d_terminalToken = false;
        bool        d_recovery = false;


    protected:
        enum Return_
        {
            PARSE_ACCEPT_ = 0,   // values used as parse()'s return values
            PARSE_ABORT_  = 1
        };
        enum ErrorRecovery_
        {
            UNEXPECTED_TOKEN_,
        };

        bool        d_actionCases_ = false;    // set by options/directives
        bool        d_debug_ = true;
        size_t      d_requiredTokens_;
        size_t      d_nErrors_;                // initialized by clearin()
        size_t      d_acceptedTokens_;
        STYPE_     d_val_;


        parserBase();

        void ABORT() const;
        void ACCEPT() const;
        void ERROR() const;

        STYPE_ &vs_(int idx);             // value stack element idx 
        int  lookup_() const;
        int  savedToken_() const;
        int  token_() const;
        size_t stackSize_() const;
        size_t state_() const;
        size_t top_() const;
        void clearin_();
        void errorVerbose_();
        void lex_(int token);
        void popToken_();
        void pop_(size_t count = 1);
        void pushToken_(int token);
        void push_(size_t nextState);
        void redoToken_();
        bool recovery_() const;
        void reduce_(int rule);
        void shift_(int state);
        void startRecovery_();

    public:
        void setDebug(bool mode);
        void setDebug(DebugMode_ mode);
}; 

// hdr/abort
inline void parserBase::ABORT() const
{
    throw PARSE_ABORT_;
}

// hdr/accept
inline void parserBase::ACCEPT() const
{
    throw PARSE_ACCEPT_;
}


// hdr/error
inline void parserBase::ERROR() const
{
    throw UNEXPECTED_TOKEN_;
}

// hdr/savedtoken
inline int parserBase::savedToken_() const
{
    return d_next.first;
}

// hdr/opbitand
inline parserBase::DebugMode_ operator&(parserBase::DebugMode_ lhs,
                                     parserBase::DebugMode_ rhs)
{
    return static_cast<parserBase::DebugMode_>(
            static_cast<int>(lhs) & rhs);
}

// hdr/opbitor
inline parserBase::DebugMode_ operator|(parserBase::DebugMode_ lhs, 
                                     parserBase::DebugMode_ rhs)
{
    return static_cast<parserBase::DebugMode_>(static_cast<int>(lhs) | rhs);
};

// hdr/recovery
inline bool parserBase::recovery_() const
{
    return d_recovery;
}

// hdr/stacksize
inline size_t parserBase::stackSize_() const
{
    return d_stackIdx + 1;
}

// hdr/state
inline size_t parserBase::state_() const
{
    return d_state;
}

// hdr/token
inline int parserBase::token_() const
{
    return d_token;
}

// hdr/vs
inline parserBase::STYPE_ &parserBase::vs_(int idx) 
{
    return (d_vsp + idx)->second;
}


// hdr/tail
// For convenience, when including ParserBase.h its symbols are available as
// symbols in the class Parser.
#define parser parserBase


// $insert namespace-close
}

#endif



